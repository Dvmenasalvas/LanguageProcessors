package constructorast;

import java_cup.runtime.*;
import alex.AnalizadorLexico;
import alex.UnidadLexica;
import alex.TokenValue;
import errors.GestionErrores;
import ast.E.*;
import ast.AS;

import java.util.List;
import java.util.ArrayList;

scan with {: return getScanner().next_token(); :};
action code {:
   private AS as = new AS();
:};
parser code {: 
   private GestionErrores errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((UnidadLexica)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErrores();
   AnalizadorLexico alex = (AnalizadorLexico)getScanner();
   alex.fijaGestionErrores(errores);
:};

//1)Terminales y no terminales
//1.1)Terminales
terminal TokenValue IGUAL, COMA, PCOMA, PUNTO, MAS, MENOS, POR, DIV, MOD, AND, OR, 
   NOT, LT, GT, LE, GE, LLAVE_A, LLAVE_C, COR_A, COR_C, PAREN_A, PAREN_C, IF, DO, POT, 
   IGUALIGUAL, INT, THEN, TRUE, FALSE, ELSE, VOID, CONST, WHILE, SWITCH, RETURN, BOOLEAN,
   DEFAULT, CASE, STRUCT, NEW, PUNTERO, IDEN, ENT;

//1.2)No terminales
non terminal Tipo TIPO, TIPO_BASICO, TIPO_PUNTERO, TIPO_ARRAY; 
non terminal E E0, E1, E2, E3, E4, E5, E6, E7, E8, E9;
non terminal List<E> LIST_ARG, CON_ARG, ARG, LIST_VAL, INIT_LIST_VAL;
non terminal List<I> S;

//2) Inicio
/*
S   ::= INST:inst S:lista_inst
{:lista_inst.add(0,inst); RESULT = lista_inst;:};
S   ::= 
{:RESULT= new ArrayList<I>();:};
*/

//3) Gramatica de expresiones (ordenada por precedencia de operadores de menos a más)
//3.1) Operadores logicos
//3.2) Operadores comparativos
//3.3) Operadores aritmeticos
//3.3.1) Suma y resta
//3.3.2) Multiplicacion, division y modulo

//3.3.3) Potencia
E5 ::= E5:e1 POT:pot E6:e2
{:RESULT=as.pot(e1, e2, pot.getFila(), pot.getColumna());:};
E5 ::= E6:e1
{:RESULT=e1;:};

//3.4) Negación
E6 ::= NOT:not E6:e1
{:RESULT=as.not(e1, not.getFila(), not.getColumna());:)};
E6 ::= E7:e1
{:RESULT=e1;:};

//3.5) Corchete, punto, asterisco y new 
E7 ::= E7:e1 COR_A:ca E0:e2 COR_C
{:RESULT=as.corchete(e1, e2, ca.getFila(), ca.getColumna());:};
//No se para que es el punto
E7  ::= PUNTERO:punt E9:op1
{:RESULT = as.dolar(op1, puntero.getFila(), puntero.getColumna());:};
E7	::= NEW:nuevo TIPO:tipo COR_A E0:tam COR_C
{:RESULT = as.nuevo(tipo, tam, nuevo.getFila(), nuevo.getColumna());:};
E7	::= NEW:nuevo TIPO:tipo COR_A COR_C
{:RESULT = as.nuevo(
   tipo, as.ent("1", nuevo.getFila(), nuevo.getColumna()), 
   nuevo.getFila(), nuevo.getColumna());:};
E7  ::= E8:op1
{:RESULT=op1;:};

//3.6) Terminales 
E8  ::= ENT:e1
{:RESULT=as.ent(e1.getLexema(), e1.getFila(), e1.getColumna());:};
E8  ::= IDEN:e1
{:RESULT=as.iden(e1.getLexema(), e1.getFila(), e1.getColumna());:};
E8  ::= PAREN_A E0:e1 PAREN_C
{:RESULT=e1;:};
E8  ::= TRUE:tru
{:RESULT=as.verdadero(tru.getFila(), tru.getColumna());:};
E8  ::= FALSE:fal
{:RESULT=as.falso(fal.getFila(), fal.getColumna());:};

//3.7)Llamada a funcion como expresion
E8  ::= IDEN:id PAREN_A LIST_ARG:args PAREN_C:pc
{:RESULT=as.llamadaFuncion(as.iden(id.getLexema(), id.getFila(), id.getColumna()), args, pc.getFila(), pc.getColumna());:};
//Sin argumentos
LIST_ARG ::=
{:RESULT=new ArrayList<E>();:};
//Con argumentos
LIST_ARG ::= E0:e1 ARG:e2
{:e2.add(0, e1); RESULT=e2;:};
ARG ::= COMA E0:e1 ARG:e2
{:e2.add(0, e1); RESULT=e2;:};
ARG ::= 
{:RESULT=new ArrayList<E>();:};