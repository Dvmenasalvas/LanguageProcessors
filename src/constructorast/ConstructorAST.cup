package constructorast;

import java_cup.runtime.*;
import alex.AnalizadorLexico;
import alex.UnidadLexica;
import alex.TokenValue;
import errors.GestionErrores;
import ast.E.*;
import ast.AS;

import java.util.List;
import java.util.ArrayList;

scan with {: return getScanner().next_token(); :};
action code {:
   private AS as = new AS();
:};
parser code {: 
   private GestionErrores errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((UnidadLexica)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErrores();
   AnalizadorLexico alex = (AnalizadorLexico)getScanner();
   alex.fijaGestionErrores(errores);
:};

//1)Terminales y no terminales
//1.1)Terminales
terminal TokenValue OR, AND, IGUALIGUAL, MAYOR, MENOR, MAYORIGUAL, MENORIGUAL, DISTINTO, IGUAL,
MAS, MENOS, POR, DIV, MOD, POT, NOT, COR_A, COR_C, PUNTERO, NEW,
TIPO, ENT, IDEN, PAREN_A, PAREN_C, LLAVE_A, LLAVE_C,
TRUE, FALSE, PUNTO, COMA, PUNTOCOMA, 
INT, BOOLEAN, IF, ELSE, RETURN, WHILE, SWITCH, CASE, DEFAULT,
CONST, STRUCT, VOID;

//1.2)No terminales
non terminal TIPO_BASICO, TIPO_PUNTERO, TIPO_ARRAY; 
non terminal E Exp0, Exp1, Exp2, Exp3, Exp4, E5, E6, E7, E8, E9;
non terminal List<E> LIST_ARG, CON_ARG, ARG, LIST_VAL, INIT_LIST_VAL;
non terminal List<I> S;

//2) Inicio
/*

*/

//3) Gramatica de expresiones (ordenada por precedencia de operadores de menos a más)

//3.1) Operadores logicos
//OR
Exp0 ::= Exp1: op1 OR:or Exp0: op2
   {:RESULT = as.or(op1, op2, or.getFila(), or.getColumna()); :};
Exp0 ::= Exp1: op1
   {:RESULT = op1; :};

//AND
Exp1 ::= Exp2:op1 AND:and Exp1:op2
   {:RESULT=as.and(op1, op2, and.getFila(), and.getColumna()); :};
Exp1 ::= Exp2: op1
   {:RESULT = op1; :};



//3.2) Operadores comparativos
// ==
Exp2 ::= Exp3:op1 IGUALIGUAL:ig Exp3:op2 
	{:RESULT = as.igualIgual(op1, op2, ig.getFila(), ig.getColumna()); :};

// >
Exp2 ::= Exp3:op1 MAYOR: ma Exp3:op2
	{:RESULT = as.mayor(op1, op2, ma.getFila(), ma.getColumna()); :}; 

// <
Exp2 ::= Exp3:op1 MENOR: me Exp3:op2 
	{:RESULT = as.menor(op1, op2, me.getFila(), me.getColumna()); :}; 

// >=
Exp2::= Exp3:op1 MAYORIGUAL: mi Exp3:op2
	{:RESULT = as.mayorIgual(op1, op2, mi.getFila(), mi.getColumna()); :}; 

// <=
Exp2::= Exp3:op1 MENORIGUAL: mi Exp3:op2
	{:RESULT = as.menorIgual(op1, op2, mi.getFila(), mi.getColumna()); :}; 

// !=
Exp2 ::= Exp3:op1 DISTINTO: dist Exp3:op2
	{:RESULT = as.distinto(op1, op2, dist.getFila(), dist.getColumna()); :}; 

Exp2 ::= Exp3: op
   {:RESULT = op; :};


//3.3) Operadores aritmeticos

//3.3.1) Suma y resta
//+
Exp3 ::= Exp3:op1 MAS:mas Exp4:op2
   {:RESULT=as.suma(op1, op2, mas.getFila(), getColumna()); :};

//-
Exp3 ::= Exp3:op1 MENOS:menos Exp4:op2
   {:RESULT=as.resta(op1, op2, menos.getFila(), menos.getColumna()); :};

Exp3 ::= Exp4:op1
   {:RESULT=op1; :};



//3.3.2) Multiplicacion, division y modulo
//*
Exp4 ::= Exp4:op1 POR:por E5:op2
   {:RESULT=as.mul(op1, op2, por.getFila(), por.getColumna()); :};

// /
Exp4 ::= Exp4:op1 DIV:div E5:op2
   {:RESULT=as.div(op1, op2, por.getFila(), por.getColumna()); :};

Exp4 ::= Exp4 :op1 MOD:mod E5:op2
   {:RESULT=as.mod(op1, op2, mod.getFila(), mod.getColumna()); :};


//3.3.3) Potencia
E5 ::= E5:e1 POT:pot E6:e2
{:RESULT=as.pot(e1, e2, pot.getFila(), pot.getColumna());:};
E5 ::= E6:e1
{:RESULT=e1;:};

//3.4) Negación
E6 ::= NOT:not E6:e1
{:RESULT=as.not(e1, not.getFila(), not.getColumna());:)};
E6 ::= E7:e1
{:RESULT=e1;:};

//3.5) Corchete, punto, asterisco y new 
E7 ::= E7:e1 COR_A:ca Exp0:e2 COR_C
{:RESULT=as.corchete(e1, e2, ca.getFila(), ca.getColumna());:};
//No se para que es el punto
E7  ::= PUNTERO:punt E9:op1
{:RESULT = as.dolar(op1, puntero.getFila(), puntero.getColumna());:};
E7	::= NEW:nuevo TIPO:tipo COR_A Exp0:tam COR_C
{:RESULT = as.nuevo(tipo, tam, nuevo.getFila(), nuevo.getColumna());:};
E7	::= NEW:nuevo TIPO:tipo COR_A COR_C
{:RESULT = as.nuevo(
   tipo, as.ent("1", nuevo.getFila(), nuevo.getColumna()), 
   nuevo.getFila(), nuevo.getColumna());:};
E7  ::= E8:op1
{:RESULT=op1;:};

//3.6) Terminales 
E8  ::= ENT:e1
{:RESULT=as.ent(e1.getLexema(), e1.getFila(), e1.getColumna());:};
E8  ::= IDEN:e1
{:RESULT=as.iden(e1.getLexema(), e1.getFila(), e1.getColumna());:};
E8  ::= PAREN_A Exp0:e1 PAREN_C
{:RESULT=e1;:};
E8  ::= TRUE:tru
{:RESULT=as.verdadero(tru.getFila(), tru.getColumna());:};
E8  ::= FALSE:fal
{:RESULT=as.falso(fal.getFila(), fal.getColumna());:};

//3.7)Llamada a funcion como expresion
E8  ::= IDEN:id PAREN_A LIST_ARG:args PAREN_C:pc
{:RESULT=as.llamadaFuncion(as.iden(id.getLexema(), id.getFila(), id.getColumna()), args, pc.getFila(), pc.getColumna());:};
//Sin argumentos
LIST_ARG ::=
{:RESULT=new ArrayList<E>();:};
//Con argumentos
LIST_ARG ::= Exp0:e1 ARG:e2
{:e2.add(0, e1); RESULT=e2;:};
ARG ::= COMA Exp0:e1 ARG:e2
{:e2.add(0, e1); RESULT=e2;:};
ARG ::= 
{:RESULT=new ArrayList<E>();:};