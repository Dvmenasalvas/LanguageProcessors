int x = 4;
int y = 5;

boolean a = true;
boolean b = false;

int V[10]= {1,2,3,4,5,6,7,8,9,10};
int V2[10] = {1,2,3,4,5,6,7,8,9,10,11,12}; #Deberia dar fallo por haber exceso de valores para guardar.

boolean a1[3] = {false,true,true};
boolean a2[3] = {false, true,3}; #Deberia dar fallo por tipo de valor a asignar.



int x = 3;
int y = 5;
boolean a = true;
boolean b = false;

#Las siguientes declaraciones son todas erroneas, pues asignamos a tipo booleano un tipo entero
#y a tipo entero un tipo booleano
boolean e1 = x / y;
boolean e2 = x * y;
boolean e3 = x **y;
boolean e4 = x+y;
boolean e5 = x-y;
boolean e6 = x % y;

int e7 = x<y;
int e8 = x>y;
int e9 = x <=y;
int e10 = x >= y;
int e11 = x ==y;

int e12 = a & b;
int e13 = !a;
int e14 = a == b;
int e15 = a | b;









# Error de vinculación mbas variablesno declaras

x = y;

# Error de tipado

int x = true;

# Error de vinculación de nuevo

call pepe(8);



# Funcion declarada con un tipo distinto del que devuelve

fun int multiplica(int x, int y){
	return true;
}

# Error de tipos mezclado con vinculacion.
# Variable m sin inicializar. Sólo se muestra este error.
# Mejor no decirle también que está mal tipada para no confudir al usuario

int z = m;


# Uso de una función de tipo innadecuado

fun bool esPositivo(int x){
	return x > 0;
}

int suma = esPositivo(3) + 4;

# Llamada a función con exceso, defecto de parametros y parametros de tipo innadecuado

bool c1 = esPositivo(3, 4);

bool c2 = esPositivo();

bool c3 = esPositivo(true);

# Hacemos una llamada correcta sin error

bool c4 = esPositivo(4);


# Cuando nos pasemos de 15 errores nos diran de que son demasiados y que se para la compilación
# Es mejor que el usuario revise su código. Y resuelva primero estos 15 errores antes de seguir

# Este error ya no lo marcará. Es el error nº 15
int y = true;









# Tipamos mal una variable
int x = true;


# No tengo un tipo para darle a x realmente (¿bool o int?)
# Se queda con el tipo de definicón. Entiende que x es de tipo int
# La primera asignación estará mal tipada y la segunda bien
bool y = x;
int z = x;

struct tPersona{
	int dinero;
	bool feliz = true;
}

tPersona juan;

# Error por un tipo de un campo de un struct
if (juan.dinero && true){

}

# Error paso de parametros a función por tipo del usuario no declarado

fun bool funcion(tNuevo tipo){
	return true;
}

# Warning por redefinición de variable. Avisa de que se queda con la primera declaración
int z;

# Error en un swicth. Tipo de los cases distinto del tipo de la variable del switch

switch(z){
case 1:
	break;
case true:
	break;
default:
}

# Error de tipo en la condición de un bucle for

for (int i = 0; i+1; i = i+1){
}

# Variable de un bucle for sin declarar, error en el paso también y en el cuerpo del bucle
# Que la variable w no está declarada sale 2 veces, una por w = 0 y otra por w = p
for(w = 0; w < 13; w = p){
	int x = False && True;
}








# Podemos combinar expresiones en partes derechas como queramos
# div indica división entera (la única soportada por la máquina-P).

# Ejemplos de expresiones enteras
int x = 3 + 2 - 1 % 7 * 5 div (-1);
int y = x + 3 * 5 % (x+3);

# Ejemplos de expresiones booleanas
bool a = x == 3 && x > y;
bool b = a || x <= 3;
bool c = !b;







