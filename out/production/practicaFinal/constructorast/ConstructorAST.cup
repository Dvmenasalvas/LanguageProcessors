package constructorast;

import java_cup.runtime.*;
import alex.AnalizadorLexico;
import alex.UnidadLexica;
import alex.TokenValue;
import errors.GestionErrores;
import ast.E.*;
import ast.I.*;
import ast.T.*;
import ast.AS;

import java.util.List;
import javafx.util.Pair;
import java.util.ArrayList;

scan with {: return getScanner().next_token(); :};
action code {:
   private AS as = new AS();
:};
parser code {: 
   private GestionErrores errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((UnidadLexica)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErrores();
   AnalizadorLexico alex = (AnalizadorLexico)getScanner();
   alex.fijaGestionErrores(errores);
:};

//1)Terminales y no terminales
//1.1)Terminales
terminal TokenValue OR, AND, IGUALIGUAL, MAYOR, MENOR, MAYORIGUAL, MENORIGUAL, DISTINTO, IGUAL,
MAS, MENOS, POR, DIV, MOD, POT, NOT, COR_A, COR_C, PUNTERO, NEW,
ENT, IDEN, PAREN_A, PAREN_C, LLAVE_A, LLAVE_C,
TRUE, FALSE, COMA, PUNTOCOMA, 
INT, BOOLEAN, IF, ELSE, RETURN, WHILE, SWITCH, CASE, DEFAULT,
CONST, STRUCT, VOID;

//1.2)No terminales
//Tipos
non terminal Tipo Tipo, TipoBasico, TipoArray;

//Expresiones
non terminal E Exp0, Exp1, Exp2, Exp3, Exp4, Exp5, Exp6, Exp7, Exp8, Exp9;

//Instrucciones
non terminal I Inst, InstIf, InstAsig, InstWhile, InstSwitch, InstDeclFun, InstCallVoidFun,
 InstDecl, InstDeclInic, InstDeclConst;

//Listas
non terminal List<I> Start;
non terminal List<E> ListArg, CON_ARG, ARG, LIST_VAL, INIT_LIST_VAL;
non terminal List<Pair<Tipo, E>> ListTipoArg, PrimerTipoArg, TipoArgs;
non terminal List<Case> ListaCase;




//2) Inicio
//Expresiones
//S   ::= Exp0:e PUNTOCOMA S:lista
//{:lista.add(0,e); RESULT = lista;:};
//S   ::=
//{:RESULT= new ArrayList<E>();:};
//Instrucciones
Start   ::= Inst:inst Start:lista_inst
{:lista_inst.add(0,inst); RESULT = lista_inst;:};
Start   ::=
{:RESULT= new ArrayList<I>();:};




//3) Gramatica de expresiones (ordenada por precedencia de operadores de menos a más)

//3.1) Operadores logicos
//OR
Exp0 ::= Exp1: op1 OR:or Exp0: op2
   {:RESULT = as.or(op1, op2, or.getFila(), or.getColumna()); :};
Exp0 ::= Exp1: op1
   {:RESULT = op1; :};

//AND
Exp1 ::= Exp2:op1 AND:and Exp1:op2
   {:RESULT=as.and(op1, op2, and.getFila(), and.getColumna()); :};
Exp1 ::= Exp2: op1
   {:RESULT = op1; :};

//3.2) Operadores comparativos
// ==
Exp2 ::= Exp3:op1 IGUALIGUAL:ig Exp3:op2
	{:RESULT = as.igualIgual(op1, op2, ig.getFila(), ig.getColumna()); :};

// >
Exp2 ::= Exp3:op1 MAYOR: ma Exp3:op2
	{:RESULT = as.mayor(op1, op2, ma.getFila(), ma.getColumna()); :};

// <
Exp2 ::= Exp3:op1 MENOR: me Exp3:op2
	{:RESULT = as.menor(op1, op2, me.getFila(), me.getColumna()); :};

// >=
Exp2::= Exp3:op1 MAYORIGUAL: mi Exp3:op2
	{:RESULT = as.mayorIgual(op1, op2, mi.getFila(), mi.getColumna()); :};

// <=
Exp2::= Exp3:op1 MENORIGUAL: mi Exp3:op2
	{:RESULT = as.menorIgual(op1, op2, mi.getFila(), mi.getColumna()); :};

// !=
Exp2 ::= Exp3:op1 DISTINTO: dist Exp3:op2
	{:RESULT = as.distinto(op1, op2, dist.getFila(), dist.getColumna()); :};

Exp2 ::= Exp3: op
   {:RESULT = op; :};

//3.3) Operadores aritmeticos

//3.3.1) Suma y resta
//+
Exp3 ::= Exp3:op1 MAS:mas Exp4:op2
   {:RESULT=as.suma(op1, op2, mas.getFila(), mas.getColumna()); :};

//-
Exp3 ::= Exp3:op1 MENOS:menos Exp4:op2
   {:RESULT=as.resta(op1, op2, menos.getFila(), menos.getColumna()); :};

Exp3 ::= Exp4:op1
   {:RESULT=op1; :};

//3.3.2) Multiplicacion, division y modulo
//*
Exp4 ::= Exp4:op1 POR:por Exp5:op2
   {:RESULT=as.mul(op1, op2, por.getFila(), por.getColumna()); :};

// /
Exp4 ::= Exp4:op1 DIV:div Exp5:op2
   {:RESULT=as.div(op1, op2, div.getFila(), div.getColumna()); :};

//%
Exp4 ::= Exp4 :op1 MOD:mod Exp5:op2
   {:RESULT=as.mod(op1, op2, mod.getFila(), mod.getColumna()); :};
Exp4 ::= Exp5:e1
{:RESULT=e1;:};


//3.3.3) Potencia
Exp5 ::= Exp5:e1 POT:pot Exp6:e2
{:RESULT=as.pot(e1, e2, pot.getFila(), pot.getColumna());:};
Exp5 ::= Exp6:e1
{:RESULT=e1;:};


//3.4) Negación
Exp6 ::= NOT:not Exp6:e1
    {:RESULT=as.not(e1, not.getFila(), not.getColumna()); :};
Exp6 ::= Exp7:e1
    {:RESULT=e1;:};


//3.5) Corchete
Exp7 ::= Exp7: e1 COR_A:ca Exp8: e2 COR_C:cc
    {:RESULT=as.corchete(e1, e2, ca.getFila(), ca.getColumna()); :};
Exp7  ::= Exp8:op1
    {:RESULT=op1;:};

//3.6) Terminales
Exp8  ::= ENT:e1
{:RESULT=as.ent(e1.getLexema(), e1.getFila(), e1.getColumna());:};
Exp8  ::= IDEN:e1
{:RESULT=as.iden(e1.getLexema(), e1.getFila(), e1.getColumna());:};
Exp8  ::= PAREN_A Exp0:e1 PAREN_C
{:RESULT=e1;:};
Exp8  ::= TRUE:tru
{:RESULT=as.verdadero(tru.getFila(), tru.getColumna());:};
Exp8  ::= FALSE:fal
{:RESULT=as.falso(fal.getFila(), fal.getColumna());:};



//4) Tipos

Tipo ::= TipoBasico:tipo_bas
    {:RESULT = tipo_bas;:};
Tipo ::= TipoArray:tipo_ar
    {:RESULT = tipo_ar;:};

//4.1) Tipos simples
TipoBasico ::= INT: in
    {:RESULT = as.tipoInt(in.getFila(), in.getColumna());:};
TipoBasico ::= BOOLEAN: boo
    {:RESULT = as.tipoBoolean(boo.getFila(), boo.getColumna());:};


//4.2) Tipo Arrays
TipoArray ::= TipoBasico:tipo_bas COR_A Exp0: dim COR_C TipoArray:tipo_ar
    {:RESULT = as.tipoArray(tipo_bas, dim, tipo_bas.getFila(), tipo_bas.getColumna());:};
//TipoArray ::=
  //  {:RESULT = null;:};


//4.2)Tipo Array
//TipoArray ::= TipoBasico:tb Dims:dims
//{:RETURN = new TipoArray(tb, dims, tb
//Dims ::= COR_A:ca Exp0:dim COR_C Dims:dims
//{:RETURN = new DimArray(dims.getDimNum() + 1, dims.getDimSize().add(0, dim), ca.getFila(), ca.getColumna());:};
//Dims ::=
//{:RETURN = new DimArray(0, new ArrayList<>());:};

//4) Gramatica de instrucciones

//4.1) Instrucciones posibles
Inst ::= InstIf:op1
{:RESULT = op1;:};
Inst ::= InstAsig:op1
{:RESULT = op1;:};
Inst ::= InstSwitch: inst1
    {:RESULT = inst1; :};
Inst ::= InstWhile:op1
{:RESULT = op1;:};
Inst ::= InstDeclFun:op
{:RESULT = op;:};
Inst ::= InstCallVoidFun:op
{:RESULT = op;:};
Inst ::= InstDecl: ins
    {:RESULT = ins;:};
Inst ::= InstDeclInic: ins
    {:RESULT = ins;:};
Inst ::= InstDeclConst: ins
    {:RESULT = ins;:};

//4.2) Instruccion asignacion
InstAsig ::= Exp0:id IGUAL:igual Exp0:valor PUNTOCOMA
{:RESULT = as.instAsignacion(id, valor, igual.getFila(), igual.getColumna());:};

//Errores

//4.3) Instruccion If
InstIf ::= IF:iff PAREN_A Exp0:condicion PAREN_C LLAVE_A Start:cuerpo LLAVE_C
{:RESULT = as.instIf(condicion, cuerpo, null, iff.getFila(), iff.getColumna());:};
InstIf ::= IF:iff PAREN_A Exp0:condicion PAREN_C LLAVE_A Start:cuerpo_if LLAVE_C ELSE LLAVE_A Start:cuerpo_else LLAVE_C
{:RESULT = as.instIf(condicion, cuerpo_if, cuerpo_else, iff.getFila(), iff.getColumna());:};

//Errores

//4.4) Instrucción while
InstWhile ::= WHILE:w PAREN_A Exp0:cond PAREN_C LLAVE_A Start:cuerpo LLAVE_C
{:RESULT = as.instWhile(cond, cuerpo, w.getFila(), w.getColumna());:};

//4.5) Instrucción switch
InstSwitch ::= SWITCH:swi PAREN_A Exp0: exp PAREN_C LLAVE_A ListaCase: lista_case LLAVE_C
    {:RESULT = as.instSwitch(exp, lista_case, swi.getFila(), swi.getColumna());:};

ListaCase::= CASE:cas Exp0:var LLAVE_A Start:cuerpo LLAVE_C ListaCase:lista_case
    {:lista_case.add(0, as.createCase(var, cuerpo, cas.getFila(), cas.getColumna()));
           RESULT = lista_case; :};

//Default
ListaCase::= DEFAULT: def LLAVE_A Start: cuerpo LLAVE_C
     {: List<Case> lista_case = new ArrayList<Case>();
    	 	lista_case.add(0, as.createCase(as.iden("default", def.getFila(), def.getColumna()), cuerpo, def.getFila(), def.getColumna()));
    	 	RESULT = lista_case; :};


// 4.6) Instrucción declaración

//4.6.1) Declaracion sin inicializar
InstDecl ::= Tipo:tip IDEN:id PUNTOCOMA
    {:RESULT = as.instDecl(tip, as.iden(id.getLexema(), id.getFila(), id.getColumna()), tip.getFila(), tip.getColumna()); :};

//4.6.2) Declaración con valores iniciales
InstDeclInic ::= Tipo:tip IDEN:id IGUAL Exp0: exp PUNTOCOMA
    {:RESULT = as.instDecl(tip, as.iden(id.getLexema(), id.getFila(), id.getColumna()), tip.getFila(), tip.getColumna()); :};

//4.6.3) Declaración constantes inicializadas obligatoriamente
InstDeclConst ::= CONST Tipo:tip IDEN:id IGUAL Exp0: exp PUNTOCOMA
    {:RESULT = as.instDeclConst(tip, as.iden(id.getLexema(), id.getFila(), id.getColumna()), tip.getFila(), tip.getColumna()); :};



//Errores

//4.8) Instrucción declaración función
InstDeclFun ::= Tipo:tipo IDEN:id PAREN_A ListTipoArg:arg PAREN_C LLAVE_A Start:cuerpo RETURN Exp0:ret PUNTOCOMA LLAVE_C
{:RESULT = as.instDeclFun(tipo, as.iden(id.getLexema(), id.getFila(), id.getColumna()),arg, cuerpo, ret, id.getFila(), id.getColumna());:};
InstDeclFun ::= VOID IDEN:id PAREN_A ListTipoArg:arg PAREN_C LLAVE_A Start:cuerpo LLAVE_C
{:RESULT = as.instDeclFun(null, as.iden(id.getLexema(), id.getFila(), id.getColumna()), arg, cuerpo, null, id.getFila(), id.getColumna());:};



//Errores

ListTipoArg ::= PrimerTipoArg:a
{:RESULT=a;:};
ListTipoArg ::=
{:RESULT=new ArrayList<Pair<Tipo, E>>();:};

PrimerTipoArg ::= Tipo:tipo IDEN:nombre  TipoArgs:otrosArgs
{:
    otrosArgs.add(0, new Pair<Tipo,E>(tipo, as.iden(nombre.getLexema(), nombre.getFila(), nombre.getColumna())));
    RESULT=otrosArgs;
:};

TipoArgs ::= COMA Tipo:tipo IDEN:nombre TipoArgs:otrosArgs
{:
  otrosArgs.add(0, new Pair<Tipo,E>(tipo, as.iden(nombre.getLexema(), nombre.getFila(), nombre.getColumna())));
  RESULT=otrosArgs;
:};

TipoArgs ::=
{:RESULT=new ArrayList<Pair<Tipo, E>>();:};

//4.9) Instrucción llamada a procedimiento
//InstCallVoidFun ::= IDEN:id PAREN_A ListArg:args PAREN_C PUNTOCOMA
//{:RESULT = as.instCallVoidFun(as.iden(id.getLexema(), id.getFila(), id.getColumna()), args, id.getFila(), id.getColumna());:};
